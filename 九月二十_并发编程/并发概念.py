# 进程 ：进行中的程序就是一个进程
    # 占用资源需要操作系统调度
    # pid 能够唯一标识一个进程
    # 计算机中最小的资源分配单位

#线程
    # 线程不能独立存在，而是存在在进程中，进程中至少有一条线程
    # 线程是进程中的一个单位，不能脱离进程存在
    # 线程是计算机能够被cpu调度的最小单位

#并发
    # 多个程序同时执行 ： 只有一个cpu 多个程序轮流在一个cpu上执行
    # 宏观上 ：多个程序同时执行
    # 微观上 ： 多个程序轮流在一个cpu上执行  本质上还是串行

#并行
    # 多个程序同时执行，并且同时在多个cpu上执行

#同步
    # 在做A事时发起B事情，必须等待B事件结束之后才能继续做A事件
        # 需要等待B的结果才能进行 A
    # 调用一个操作，需要等待结果
#异步
    # 在做A事时发起B事件，不需要等待B事件结束就可以进行A事件
        #不需要等待B的结果就可以进行A事件
    # 调用一个操作，不需要等待结果
# 阻塞
    # 如果cpu不工作
# 非阻塞
    # cpu在工作
# 同步阻塞
    # input sleep recv recvform等
# 同步非阻塞
    #ret = eval('1+2+3')
# 异步阻塞

# 异步非阻塞
# import socket
#
# sk = socket.socket()
# sk.setblocking(False)
# sk.bind(('127.0.0.1',9000))
# sk.listen()
# while True:
#  ！！重要！！
# 该操作会一直占用cpu ，不会把cpu让给别人
#     try:
#         conn,addr = sk.accept()
#     except BlockingIOError:
#         pass

# 并发三部曲
# import time
#
# print('开始运行')
#
# name = input("阻塞")
#
# print('就绪')
#
# print(f'{name}:运行')
# print('time.sleep阻塞一秒')
# time.sleep(1)
# print('回到就绪')
# print('运行然后结束')



# 进程的调度算法
    #给所有的进程分配资源或者分配cpu使用权的一种方法
    #短作业优先
    #先来先服务
    #多级反馈算法
        # 把每一个任务放在多个列表中
        # 每个列表的优先级从高到低
        # 列表中存放进程
        # 调度这个进程后，执行一个时间片的时间
        # 只有优先级高的列表中没有进程之后才会去执行次优先级的列表中的进程
        # 每个进程  所执行的时间片的长度也不尽相同
        # 一般来说，优先级越高的队列中，时间片越短
        # 在同一个队列中的进程按照时间片轮转的方式就来调用
        # 如果队列Q1中时间片为 5 ，而Q1中的进程1 在完成了这个时间片后还没有结束则把这个进程下放到次一级的队列中
        # 如果在次一级的队列中完成了该队列的时间片还是没有完成 该进程则继续下放，直到完成
        # 新来的进程几乎会立即获得一个时间片时间
        # 在正在运行的进程结束当前时间片以后，会立即执行新来的任务
        # 





