#  死锁是怎么产生的？
   # 多把锁，并且在多个线程中   交叉·使用
   # 多进程或者线程，争夺 资源导致互相等待
   # 要是没有外力作用， 他们都将无法继续进行下去

#死锁产生了之后，想解决该怎么办？
    # 如果是互斥锁产生了 死锁现象 ， 最快速是的解决办法是把所有的互斥锁 修改成 同一把 递归锁 即可
    # 这种方法虽然 能够解决死锁 ，但是会降低 效率
    #


# 死锁产生的 四个必要条件：
    # 互斥条件  ： 一个资源在 某一时刻只能被一个进程或者线程占用
    # 请求和保持条件： 进程/线程 在持有至少一个资源的情况下，又去请求新的资源，在请求新的资源的时候 不会释放手里的资源
        #(我抢到叉子的情况下，还要继续请求争抢拉面，抢拉面时不会 把叉子拱手让人)
    # 不可剥夺条件
        #进程或者 线程已经抢到的资源在没使用之前，不能被其他进程强行夺走，只能等我用完了，或者不要了，别人才能用
        #在我抢到叉子以后，不能因为我没抢到拉面，就让我把叉子 送给别人，只能时我用好了，或者不要了 ，把叉子 扔回去 ，别人才能继续抢
    # 循环等待条件
        #存在一组进程或者 线程   其中每个进程都在等待下一个进程所持有的资源，形成了一个循环等待的链条
            # 我抢到了 叉子， 你抢到了 拉面 ，我在等你 释放拉面资源， 你在等我释放叉子资源，大家互相等待，形成死循环，局面僵持
    #总结：  #(互相占有资源导致死循环)
            # (我不给，你不能抢)
            # (我有叉子需要拉面，请求拉面，就算抢不到拉面，但不会给别人叉子)(我有这个条件，我吃不上第一口，谁都别想吃，大家都等着吧)(犟种原则)
            # (只有一个叉子，我拿到，别人就拿不到)
            # 1、循环请求  2、不可剥夺  3、请求和保持  4、互斥条件